%This is the change file for the original Docker's Documentation file.
%This is part of Japanese translation version for Docker's Documantation.

% __SUBDIR__ 対応 / .md リンクへの (no slash) 対応

@x
title: Use containers for Go development
linkTitle: Develop your app
@y
title: コンテナーを利用した Go 言語の開発
linkTitle: アプリの開発
@z

@x
keywords: get started, go, golang, local, development
description: Learn how to develop your application locally.
@y
keywords: get started, go, golang, local, development
description: Learn how to develop your application locally.
@z

@x
## Prerequisites
@y
## Prerequisites
@z

@x
Work through the steps of the [run your image as a container](run-containers.md) module to learn how to manage the lifecycle of your containers.
@y
Work through the steps of the [run your image as a container](run-containers.md) module to learn how to manage the lifecycle of your containers.
@z

@x
## Introduction
@y
## Introduction
@z

@x
In this module, you'll take a look at running a database engine in a container and connecting it to the extended version of the example application. You are going to see some options for keeping persistent data and for wiring up the containers to talk to one another. Finally, you'll learn how to use Docker Compose to manage such multi-container local development environments effectively.
@y
In this module, you'll take a look at running a database engine in a container and connecting it to the extended version of the example application. You are going to see some options for keeping persistent data and for wiring up the containers to talk to one another. Finally, you'll learn how to use Docker Compose to manage such multi-container local development environments effectively.
@z

@x
## Local database and containers
@y
## Local database and containers
@z

@x
The database engine you are going to use is called [CockroachDB](https://www.cockroachlabs.com/product/). It is a modern, Cloud-native, distributed SQL database.
@y
The database engine you are going to use is called [CockroachDB](https://www.cockroachlabs.com/product/). It is a modern, Cloud-native, distributed SQL database.
@z

@x
Instead of compiling CockroachDB from the source code or using the operating system's native package manager to install CockroachDB, you are going to use the [Docker image for CockroachDB](https://hub.docker.com/r/cockroachdb/cockroach) and run it in a container.
@y
Instead of compiling CockroachDB from the source code or using the operating system's native package manager to install CockroachDB, you are going to use the [Docker image for CockroachDB](https://hub.docker.com/r/cockroachdb/cockroach) and run it in a container.
@z

@x
CockroachDB is compatible with PostgreSQL to a significant extent, and shares many conventions with the latter, particularly the default names for the environment variables. So, if you are familiar with Postgres, don't be surprised if you see some familiar environment variables names. The Go modules that work with Postgres, such as [pgx](https://pkg.go.dev/github.com/jackc/pgx), [pq](https://pkg.go.dev/github.com/lib/pq), [GORM](https://gorm.io/index.html), and [upper/db](https://upper.io/v4/) also work with CockroachDB.
@y
CockroachDB is compatible with PostgreSQL to a significant extent, and shares many conventions with the latter, particularly the default names for the environment variables. So, if you are familiar with Postgres, don't be surprised if you see some familiar environment variables names. The Go modules that work with Postgres, such as [pgx](https://pkg.go.dev/github.com/jackc/pgx), [pq](https://pkg.go.dev/github.com/lib/pq), [GORM](https://gorm.io/index.html), and [upper/db](https://upper.io/v4/) also work with CockroachDB.
@z

@x
For more information on the relation between Go and CockroachDB, refer to the [CockroachDB documentation](https://www.cockroachlabs.com/docs/v20.2/build-a-go-app-with-cockroachdb.html), although this isn't necessary to continue with the present guide.
@y
For more information on the relation between Go and CockroachDB, refer to the [CockroachDB documentation](https://www.cockroachlabs.com/docs/v20.2/build-a-go-app-with-cockroachdb.html), although this isn't necessary to continue with the present guide.
@z

@x
### Storage
@y
### Storage
@z

@x
The point of a database is to have a persistent store of data. [Volumes](/manuals/engine/storage/volumes.md) are the preferred mechanism for persisting data generated by and used by Docker containers. Thus, before you start CockroachDB, create the volume for it.
@y
The point of a database is to have a persistent store of data. [Volumes](manuals/engine/storage/volumes.md) are the preferred mechanism for persisting data generated by and used by Docker containers. Thus, before you start CockroachDB, create the volume for it.
@z

@x
To create a managed volume, run :
@y
To create a managed volume, run :
@z

% snip command...

@x
You can view the list of all managed volumes in your Docker instance with the following command:
@y
You can view the list of all managed volumes in your Docker instance with the following command:
@z

% snip command...

@x
### Networking
@y
### Networking
@z

@x
The example application and the database engine are going to talk to one another over the network. There are different kinds of network configuration possible, and you're going to use what's called a user-defined bridge network. It is going to provide you with a DNS lookup service so that you can refer to your database engine container by its hostname.
@y
The example application and the database engine are going to talk to one another over the network. There are different kinds of network configuration possible, and you're going to use what's called a user-defined bridge network. It is going to provide you with a DNS lookup service so that you can refer to your database engine container by its hostname.
@z

@x
The following command creates a new bridge network named `mynet`:
@y
The following command creates a new bridge network named `mynet`:
@z

% snip command...

@x
As it was the case with the managed volumes, there is a command to list all networks set up in your Docker instance:
@y
As it was the case with the managed volumes, there is a command to list all networks set up in your Docker instance:
@z

% snip command...

@x
Your bridge network `mynet` has been created successfully. The other three networks, named `bridge`, `host`, and `none` are the default networks and they had been created by the Docker itself. While it's not relevant to this guide, you can learn more about Docker networking in the [networking overview](/manuals/engine/network/_index.md) section.
@y
Your bridge network `mynet` has been created successfully. The other three networks, named `bridge`, `host`, and `none` are the default networks and they had been created by the Docker itself. While it's not relevant to this guide, you can learn more about Docker networking in the [networking overview](manuals/engine/network/_index.md) section.
@z

@x
### Choose good names for volumes and networks
@y
### Choose good names for volumes and networks
@z

@x
As the saying goes, there are only two hard things in Computer Science: cache invalidation and naming things. And off-by-one errors.
@y
As the saying goes, there are only two hard things in Computer Science: cache invalidation and naming things. And off-by-one errors.
@z

@x
When choosing a name for a network or a managed volume, it's best to choose a name that's indicative of the intended purpose. This guide aims for brevity, so it used short, generic names.
@y
When choosing a name for a network or a managed volume, it's best to choose a name that's indicative of the intended purpose. This guide aims for brevity, so it used short, generic names.
@z

@x
### Start the database engine
@y
### Start the database engine
@z

@x
Now that the housekeeping chores are done, you can run CockroachDB in a container and attach it to the volume and network you had just created. When you run the following command, Docker will pull the image from Docker Hub and run it for you locally:
@y
Now that the housekeeping chores are done, you can run CockroachDB in a container and attach it to the volume and network you had just created. When you run the following command, Docker will pull the image from Docker Hub and run it for you locally:
@z

% snip command...

@x
Notice a clever use of the tag `latest-v20.1` to make sure that you're pulling the latest patch version of 20.1. The diversity of available tags depend on the image maintainer. Here, your intent was to have the latest patched version of CockroachDB while not straying too far away from the known working version as the time goes by. To see the tags available for the CockroachDB image, you can go to the [CockroachDB page on Docker Hub](https://hub.docker.com/r/cockroachdb/cockroach/tags).
@y
Notice a clever use of the tag `latest-v20.1` to make sure that you're pulling the latest patch version of 20.1. The diversity of available tags depend on the image maintainer. Here, your intent was to have the latest patched version of CockroachDB while not straying too far away from the known working version as the time goes by. To see the tags available for the CockroachDB image, you can go to the [CockroachDB page on Docker Hub](https://hub.docker.com/r/cockroachdb/cockroach/tags).
@z

@x
### Configure the database engine
@y
### Configure the database engine
@z

@x
Now that the database engine is live, there is some configuration to do before your application can begin using it. Fortunately, it's not a lot. You must:
@y
Now that the database engine is live, there is some configuration to do before your application can begin using it. Fortunately, it's not a lot. You must:
@z

@x
1. Create a blank database.
2. Register a new user account with the database engine.
3. Grant that new user access rights to the database.
@y
1. Create a blank database.
2. Register a new user account with the database engine.
3. Grant that new user access rights to the database.
@z

@x
You can do that with the help of CockroachDB built-in SQL shell. To start the SQL shell in the same container where the database engine is running, type:
@y
You can do that with the help of CockroachDB built-in SQL shell. To start the SQL shell in the same container where the database engine is running, type:
@z

% snip command...

@x
1. In the SQL shell, create the database that the example application is going to use:
@y
1. In the SQL shell, create the database that the example application is going to use:
@z

% snip command...

@x
2. Register a new SQL user account with the database engine. Use the username `totoro`.
@y
2. Register a new SQL user account with the database engine. Use the username `totoro`.
@z

% snip command...

@x
3. Give the new user the necessary permissions:
@y
3. Give the new user the necessary permissions:
@z

% snip command...

@x
4. Type `quit` to exit the shell.
@y
4. Type `quit` to exit the shell.
@z

@x
The following is an example of interaction with the SQL shell.
@y
The following is an example of interaction with the SQL shell.
@z

% snip command...

@x
### Meet the example application
@y
### Meet the example application
@z

@x
Now that you have started and configured the database engine, you can switch your attention to the application.
@y
Now that you have started and configured the database engine, you can switch your attention to the application.
@z

@x
The example application for this module is an extended version of `docker-gs-ping` application you've used in the previous modules. You have two options:
@y
The example application for this module is an extended version of `docker-gs-ping` application you've used in the previous modules. You have two options:
@z

@x
- You can update your local copy of `docker-gs-ping` to match the new extended version presented in this chapter; or
- You can clone the [docker/docker-gs-ping-dev](https://github.com/docker/docker-gs-ping-dev) repository. This latter approach is recommended.
@y
- You can update your local copy of `docker-gs-ping` to match the new extended version presented in this chapter; or
- You can clone the [docker/docker-gs-ping-dev](https://github.com/docker/docker-gs-ping-dev) repository. This latter approach is recommended.
@z

@x
To checkout the example application, run:
@y
To checkout the example application, run:
@z

% snip command...

@x
The application's `main.go` now includes database initialization code, as well as the code to implement a new business requirement:
@y
The application's `main.go` now includes database initialization code, as well as the code to implement a new business requirement:
@z

@x
- An HTTP `POST` request to `/send` containing a `{ "value" : string }` JSON must save the value to the database.
@y
- An HTTP `POST` request to `/send` containing a `{ "value" : string }` JSON must save the value to the database.
@z

@x
You also have an update for another business requirement. The requirement was:
@y
You also have an update for another business requirement. The requirement was:
@z

@x
- The application responds with a text message containing a heart symbol ("`<3`") on requests to `/`.
@y
- The application responds with a text message containing a heart symbol ("`<3`") on requests to `/`.
@z

@x
And now it's going to be:
@y
And now it's going to be:
@z

@x
- The application responds with the string containing the count of messages stored in the database, enclosed in the parentheses.
@y
- The application responds with the string containing the count of messages stored in the database, enclosed in the parentheses.
@z

@x
  Example output: `Hello, Docker! (7)`
@y
  Example output: `Hello, Docker! (7)`
@z

@x
The full source code listing of `main.go` follows.
@y
The full source code listing of `main.go` follows.
@z

% snip code...

@x
The repository also includes the `Dockerfile`, which is almost exactly the same as the multi-stage `Dockerfile` introduced in the previous modules. It uses the official Docker Go image to build the application and then builds the final image by placing the compiled binary into the much slimmer, distroless image.
@y
The repository also includes the `Dockerfile`, which is almost exactly the same as the multi-stage `Dockerfile` introduced in the previous modules. It uses the official Docker Go image to build the application and then builds the final image by placing the compiled binary into the much slimmer, distroless image.
@z

@x
Regardless of whether you had updated the old example application, or checked out the new one, this new Docker image has to be built to reflect the changes to the application source code.
@y
Regardless of whether you had updated the old example application, or checked out the new one, this new Docker image has to be built to reflect the changes to the application source code.
@z

@x
### Build the application
@y
### Build the application
@z

@x
You can build the image with the familiar `build` command:
@y
You can build the image with the familiar `build` command:
@z

% snip command...

@x
### Run the application
@y
### Run the application
@z

@x
Now, run your container. This time you'll need to set some environment variables so that your application knows how to access the database. For now, you’ll do this right in the `docker run` command. Later you'll see a more convenient method with Docker Compose.
@y
Now, run your container. This time you'll need to set some environment variables so that your application knows how to access the database. For now, you’ll do this right in the `docker run` command. Later you'll see a more convenient method with Docker Compose.
@z

@x
> [!NOTE]
>
> Since you're running your CockroachDB cluster in insecure mode, the value for the password can be anything.
>
> In production, don't run in insecure mode.
@y
> [!NOTE]
>
> Since you're running your CockroachDB cluster in insecure mode, the value for the password can be anything.
>
> In production, don't run in insecure mode.
@z

% snip command...

@x
There are a few points to note about this command.
@y
There are a few points to note about this command.
@z

@x
- You map container port `8080` to host port `80` this time. Thus, for `GET` requests you can get away with literally `curl localhost`:
@y
- You map container port `8080` to host port `80` this time. Thus, for `GET` requests you can get away with literally `curl localhost`:
@z

% snip command...

@x
  Or, if you prefer, a proper URL would work just as well:
@y
  Or, if you prefer, a proper URL would work just as well:
@z

% snip command...

@x
- The total number of stored messages is `0` for now. This is fine, because you haven't posted anything to your application yet.
- You refer to the database container by its hostname, which is `db`. This is why you had `--hostname db` when you started the database container.
@y
- The total number of stored messages is `0` for now. This is fine, because you haven't posted anything to your application yet.
- You refer to the database container by its hostname, which is `db`. This is why you had `--hostname db` when you started the database container.
@z

@x
- The actual password doesn't matter, but it must be set to something to avoid confusing the example application.
- The container you've just run is named `rest-server`. These names are useful for managing the container lifecycle:
@y
- The actual password doesn't matter, but it must be set to something to avoid confusing the example application.
- The container you've just run is named `rest-server`. These names are useful for managing the container lifecycle:
@z

% snip command...

@x
### Test the application
@y
### Test the application
@z

@x
In the previous section, you've already tested querying your application with `GET` and it returned zero for the stored message counter. Now, post some messages to it:
@y
In the previous section, you've already tested querying your application with `GET` and it returned zero for the stored message counter. Now, post some messages to it:
@z

% snip command...

@x
The application responds with the contents of the message, which means it has been saved in the database:
@y
The application responds with the contents of the message, which means it has been saved in the database:
@z

% snip code...

@x
Send another message:
@y
Send another message:
@z

% snip command...

@x
And again, you get the value of the message back:
@y
And again, you get the value of the message back:
@z

% snip code...

@x
Run curl and see what the message counter says:
@y
Run curl and see what the message counter says:
@z

% snip command...

@x
In this example, you sent two messages and the database kept them. Or has it? Stop and remove all your containers, but not the volumes, and try again.
@y
In this example, you sent two messages and the database kept them. Or has it? Stop and remove all your containers, but not the volumes, and try again.
@z

@x
First, stop the containers:
@y
First, stop the containers:
@z

% snip command...

@x
Then, remove them:
@y
Then, remove them:
@z

% snip command...

@x
Verify that they're gone:
@y
Verify that they're gone:
@z

% snip command...

@x
And start them again, database first:
@y
And start them again, database first:
@z

% snip command...

@x
And the service next:
@y
And the service next:
@z

% snip command...

@x
Lastly, query your service:
@y
Lastly, query your service:
@z

% snip command...

@x
Great! The count of records from the database is correct although you haven't only stopped the containers, but you've also removed them before starting new instances. The difference is in the managed volume for CockroachDB, which you reused. The new CockroachDB container has read the database files from the disk, just as it normally would if it were running outside the container.
@y
Great! The count of records from the database is correct although you haven't only stopped the containers, but you've also removed them before starting new instances. The difference is in the managed volume for CockroachDB, which you reused. The new CockroachDB container has read the database files from the disk, just as it normally would if it were running outside the container.
@z

@x
### Wind down everything
@y
### Wind down everything
@z

@x
Remember, that you're running CockroachDB in insecure mode. Now that you've built and tested your application, it's time to wind everything down before moving on. You can list the containers that you are running with the `list` command:
@y
Remember, that you're running CockroachDB in insecure mode. Now that you've built and tested your application, it's time to wind everything down before moving on. You can list the containers that you are running with the `list` command:
@z

% snip command...

@x
Now that you know the container IDs, you can use `docker container stop` and `docker container rm`, as demonstrated in the previous modules.
@y
Now that you know the container IDs, you can use `docker container stop` and `docker container rm`, as demonstrated in the previous modules.
@z

@x
Stop the CockroachDB and `docker-gs-ping-roach` containers before moving on.
@y
Stop the CockroachDB and `docker-gs-ping-roach` containers before moving on.
@z

@x
## Better productivity with Docker Compose
@y
## Better productivity with Docker Compose
@z

@x
At this point, you might be wondering if there is a way to avoid having to deal with long lists of arguments to the `docker` command. The toy example you used in this series requires five environment variables to define the connection to the database. A real application might need many, many more. Then there is also a question of dependencies. Ideally, you want to make sure that the database is started before your application is run. And spinning up the database instance may require another Docker command with many options. But there is a better way to orchestrate these deployments for local development purposes.
@y
At this point, you might be wondering if there is a way to avoid having to deal with long lists of arguments to the `docker` command. The toy example you used in this series requires five environment variables to define the connection to the database. A real application might need many, many more. Then there is also a question of dependencies. Ideally, you want to make sure that the database is started before your application is run. And spinning up the database instance may require another Docker command with many options. But there is a better way to orchestrate these deployments for local development purposes.
@z

@x
In this section, you'll create a Docker Compose file to start your `docker-gs-ping-roach` application and CockroachDB database engine with a single command.
@y
In this section, you'll create a Docker Compose file to start your `docker-gs-ping-roach` application and CockroachDB database engine with a single command.
@z

@x
### Configure Docker Compose
@y
### Configure Docker Compose
@z

@x
In your application's directory, create a new text file named `docker-compose.yml` with the following content.
@y
In your application's directory, create a new text file named `docker-compose.yml` with the following content.
@z

% snip code...

@x
This Docker Compose configuration is super convenient as you don't have to type all the parameters to pass to the `docker run` command. You can declaratively do that in the Docker Compose file. The [Docker Compose documentation pages](/manuals/compose/_index.md) are quite extensive and include a full reference for the Docker Compose file format.
@y
This Docker Compose configuration is super convenient as you don't have to type all the parameters to pass to the `docker run` command. You can declaratively do that in the Docker Compose file. The [Docker Compose documentation pages](manuals/compose/_index.md) are quite extensive and include a full reference for the Docker Compose file format.
@z

@x
### The `.env` file
@y
### The `.env` file
@z

@x
Docker Compose will automatically read environment variables from a `.env` file if it's available. Since your Compose file requires `PGPASSWORD` to be set, add the following content to the `.env` file:
@y
Docker Compose will automatically read environment variables from a `.env` file if it's available. Since your Compose file requires `PGPASSWORD` to be set, add the following content to the `.env` file:
@z

% snip code...

@x
The exact value doesn't really matter for this example, because you run CockroachDB in insecure mode. Make sure you set the variable to some value to avoid getting an error.
@y
The exact value doesn't really matter for this example, because you run CockroachDB in insecure mode. Make sure you set the variable to some value to avoid getting an error.
@z

@x
### Merging Compose files
@y
### Merging Compose files
@z

@x
The file name `docker-compose.yml` is the default file name which `docker compose` command recognizes if no `-f` flag is provided. This means you can have multiple Docker Compose files if your environment has such requirements. Furthermore, Docker Compose files are... composable (pun intended), so multiple files can be specified on the command line to merge parts of the configuration together. The following list is just a few examples of scenarios where such a feature would be very useful:
@y
The file name `docker-compose.yml` is the default file name which `docker compose` command recognizes if no `-f` flag is provided. This means you can have multiple Docker Compose files if your environment has such requirements. Furthermore, Docker Compose files are... composable (pun intended), so multiple files can be specified on the command line to merge parts of the configuration together. The following list is just a few examples of scenarios where such a feature would be very useful:
@z

@x
- Using a bind mount for the source code for local development but not when running the CI tests;
- Switching between using a pre-built image for the frontend for some API application vs creating a bind mount for source code;
- Adding additional services for integration testing;
- And many more...
@y
- Using a bind mount for the source code for local development but not when running the CI tests;
- Switching between using a pre-built image for the frontend for some API application vs creating a bind mount for source code;
- Adding additional services for integration testing;
- And many more...
@z

@x
You aren't going to cover any of these advanced use cases here.
@y
You aren't going to cover any of these advanced use cases here.
@z

@x
### Variable substitution in Docker Compose
@y
### Variable substitution in Docker Compose
@z

@x
One of the really cool features of Docker Compose is [variable substitution](/reference/compose-file/interpolation.md). You can see some examples in the Compose file, `environment` section. By means of an example:
@y
One of the really cool features of Docker Compose is [variable substitution](reference/compose-file/interpolation.md). You can see some examples in the Compose file, `environment` section. By means of an example:
@z

@x
- `PGUSER=${PGUSER:-totoro}` means that inside the container, the environment variable `PGUSER` shall be set to the same value as it has on the host machine where Docker Compose is run. If there is no environment variable with this name on the host machine, the variable inside the container gets the default value of `totoro`.
- `PGPASSWORD=${PGPASSWORD:?database password not set}` means that if the environment variable `PGPASSWORD` isn't set on the host, Docker Compose will display an error. This is OK, because you don't want to hard-code default values for the password. You set the password value in the `.env` file, which is local to your machine. It is always a good idea to add `.env` to `.gitignore` to prevent the secrets being checked into the version control.
@y
- `PGUSER=${PGUSER:-totoro}` means that inside the container, the environment variable `PGUSER` shall be set to the same value as it has on the host machine where Docker Compose is run. If there is no environment variable with this name on the host machine, the variable inside the container gets the default value of `totoro`.
- `PGPASSWORD=${PGPASSWORD:?database password not set}` means that if the environment variable `PGPASSWORD` isn't set on the host, Docker Compose will display an error. This is OK, because you don't want to hard-code default values for the password. You set the password value in the `.env` file, which is local to your machine. It is always a good idea to add `.env` to `.gitignore` to prevent the secrets being checked into the version control.
@z

@x
Other ways of dealing with undefined or empty values exist, as documented in the [variable substitution](/reference/compose-file/interpolation.md) section of the Docker documentation.
@y
Other ways of dealing with undefined or empty values exist, as documented in the [variable substitution](reference/compose-file/interpolation.md) section of the Docker documentation.
@z

@x
### Validating Docker Compose configuration
@y
### Validating Docker Compose configuration
@z

@x
Before you apply changes made to a Compose configuration file, there is an opportunity to validate the content of the configuration file with the following command:
@y
Before you apply changes made to a Compose configuration file, there is an opportunity to validate the content of the configuration file with the following command:
@z

% snip command...

@x
When this command is run, Docker Compose reads the file `docker-compose.yml`, parses it into a data structure in memory, validates where possible, and prints back the reconstruction of that configuration file from its internal representation. If this isn't possible due to errors, Docker prints an error message instead.
@y
When this command is run, Docker Compose reads the file `docker-compose.yml`, parses it into a data structure in memory, validates where possible, and prints back the reconstruction of that configuration file from its internal representation. If this isn't possible due to errors, Docker prints an error message instead.
@z

@x
### Build and run the application using Docker Compose
@y
### Build and run the application using Docker Compose
@z

@x
Start your application and confirm that it's running.
@y
Start your application and confirm that it's running.
@z

% snip command...

@x
You passed the `--build` flag so Docker will compile your image and then start it.
@y
You passed the `--build` flag so Docker will compile your image and then start it.
@z

@x
> [!NOTE]
>
> Docker Compose is a useful tool, but it has its own quirks. For example, no rebuild is triggered on the update to the source code unless the `--build` flag is provided. It is a very common pitfall to edit one's source code, and forget to use the `--build` flag when running `docker compose up`.
@y
> [!NOTE]
>
> Docker Compose is a useful tool, but it has its own quirks. For example, no rebuild is triggered on the update to the source code unless the `--build` flag is provided. It is a very common pitfall to edit one's source code, and forget to use the `--build` flag when running `docker compose up`.
@z

@x
Since your set-up is now run by Docker Compose, it has assigned it a project name, so you get a new volume for your CockroachDB instance. This means that your application will fail to connect to the database, because the database doesn't exist in this new volume. The terminal displays an authentication error for the database:
@y
Since your set-up is now run by Docker Compose, it has assigned it a project name, so you get a new volume for your CockroachDB instance. This means that your application will fail to connect to the database, because the database doesn't exist in this new volume. The terminal displays an authentication error for the database:
@z

% snip output...

@x
Because of the way you set up your deployment using `restart_policy`, the failing container is being restarted every 20 seconds. So, in order to fix the problem, you need to log in to the database engine and create the user. You've done it before in [Configure the database engine](#configure-the-database-engine).
@y
Because of the way you set up your deployment using `restart_policy`, the failing container is being restarted every 20 seconds. So, in order to fix the problem, you need to log in to the database engine and create the user. You've done it before in [Configure the database engine](#configure-the-database-engine).
@z

@x
This isn't a big deal. All you have to do is to connect to CockroachDB instance and run the three SQL commands to create the database and the user, as described in [Configure the database engine](#configure-the-database-engine).
@y
This isn't a big deal. All you have to do is to connect to CockroachDB instance and run the three SQL commands to create the database and the user, as described in [Configure the database engine](#configure-the-database-engine).
@z

@x
So, log in to the database engine from another terminal:
@y
So, log in to the database engine from another terminal:
@z

% snip command...

@x
And run the same commands as before to create the database `mydb`, the user `totoro`, and to grant that user necessary permissions. Once you do that (and the example application container is automatically restarts), the `rest-service` stops failing and restarting and the console goes quiet.
@y
And run the same commands as before to create the database `mydb`, the user `totoro`, and to grant that user necessary permissions. Once you do that (and the example application container is automatically restarts), the `rest-service` stops failing and restarting and the console goes quiet.
@z

@x
It would have been possible to connect the volume that you had previously used, but for the purposes of this example it's more trouble than it's worth and it also provided an opportunity to show how to introduce resilience into your deployment via the `restart_policy` Compose file feature.
@y
It would have been possible to connect the volume that you had previously used, but for the purposes of this example it's more trouble than it's worth and it also provided an opportunity to show how to introduce resilience into your deployment via the `restart_policy` Compose file feature.
@z

@x
### Testing the application
@y
### Testing the application
@z

@x
Now, test your API endpoint. In the new terminal, run the following command:
@y
Now, test your API endpoint. In the new terminal, run the following command:
@z

% snip command...

@x
You should receive the following response:
@y
You should receive the following response:
@z

% snip output...

@x
### Shutting down
@y
### Shutting down
@z

@x
To stop the containers started by Docker Compose, press `ctrl+c` in the terminal where you ran `docker compose up`. To remove those containers after they've been stopped, run `docker compose down`.
@y
To stop the containers started by Docker Compose, press `ctrl+c` in the terminal where you ran `docker compose up`. To remove those containers after they've been stopped, run `docker compose down`.
@z

@x
### Detached mode
@y
### Detached mode
@z

@x
You can run containers started by the `docker compose` command in detached mode, just as you would with the `docker` command, by using the `-d` flag.
@y
You can run containers started by the `docker compose` command in detached mode, just as you would with the `docker` command, by using the `-d` flag.
@z

@x
To start the stack, defined by the Compose file in detached mode, run:
@y
To start the stack, defined by the Compose file in detached mode, run:
@z

% snip command...

@x
Then, you can use `docker compose stop` to stop the containers and `docker compose down` to remove them.
@y
Then, you can use `docker compose stop` to stop the containers and `docker compose down` to remove them.
@z

@x
## Further exploration
@y
## Further exploration
@z

@x
You can run `docker compose` to see what other commands are available.
@y
You can run `docker compose` to see what other commands are available.
@z

@x
## Wrap up
@y
## Wrap up
@z

@x
There are some tangential, yet interesting points that were purposefully not covered in this chapter. For the more adventurous reader, this section offers some pointers for further study.
@y
There are some tangential, yet interesting points that were purposefully not covered in this chapter. For the more adventurous reader, this section offers some pointers for further study.
@z

@x
### Persistent storage
@y
### Persistent storage
@z

@x
A managed volume isn't the only way to provide your container with persistent storage. It is highly recommended to get acquainted with available storage options and their use cases, covered in [Manage data in Docker](/manuals/engine/storage/_index.md).
@y
A managed volume isn't the only way to provide your container with persistent storage. It is highly recommended to get acquainted with available storage options and their use cases, covered in [Manage data in Docker](manuals/engine/storage/_index.md).
@z

@x
### CockroachDB clusters
@y
### CockroachDB clusters
@z

@x
You ran a single instance of CockroachDB, which was enough for this example. But, it's possible to run a CockroachDB cluster, which is made of multiple instances of CockroachDB, each instance running in its own container. Since CockroachDB engine is distributed by design, it would have taken surprisingly little change to your procedure to run a cluster with multiple nodes.
@y
You ran a single instance of CockroachDB, which was enough for this example. But, it's possible to run a CockroachDB cluster, which is made of multiple instances of CockroachDB, each instance running in its own container. Since CockroachDB engine is distributed by design, it would have taken surprisingly little change to your procedure to run a cluster with multiple nodes.
@z

@x
Such distributed set-up offers interesting possibilities, such as applying Chaos Engineering techniques to simulate parts of the cluster failing and evaluating your application's ability to cope with such failures.
@y
Such distributed set-up offers interesting possibilities, such as applying Chaos Engineering techniques to simulate parts of the cluster failing and evaluating your application's ability to cope with such failures.
@z

@x
If you are interested in experimenting with CockroachDB clusters, check out:
@y
If you are interested in experimenting with CockroachDB clusters, check out:
@z

@x
- [Start a CockroachDB Cluster in Docker](https://www.cockroachlabs.com/docs/v20.2/start-a-local-cluster-in-docker-mac.html) article; and
- Documentation for Docker Compose keywords [`deploy`](/reference/compose-file/legacy-versions.md) and [`replicas`](/reference/compose-file/legacy-versions.md).
@y
- [Start a CockroachDB Cluster in Docker](https://www.cockroachlabs.com/docs/v20.2/start-a-local-cluster-in-docker-mac.html) article; and
- Documentation for Docker Compose keywords [`deploy`](reference/compose-file/legacy-versions.md) and [`replicas`](reference/compose-file/legacy-versions.md).
@z

@x
### Other databases
@y
### Other databases
@z

@x
Since you didn't run a cluster of CockroachDB instances, you might be wondering whether you could have used a non-distributed database engine. The answer is 'yes', and if you were to pick a more traditional SQL database, such as [PostgreSQL](https://www.postgresql.org/), the process described in this chapter would have been very similar.
@y
Since you didn't run a cluster of CockroachDB instances, you might be wondering whether you could have used a non-distributed database engine. The answer is 'yes', and if you were to pick a more traditional SQL database, such as [PostgreSQL](https://www.postgresql.org/), the process described in this chapter would have been very similar.
@z

@x
## Next steps
@y
## Next steps
@z

@x
In this module, you set up a containerized development environment with your application and the database engine running in different containers. You also wrote a Docker Compose file which links the two containers together and provides for easy starting up and tearing down of the development environment.
@y
In this module, you set up a containerized development environment with your application and the database engine running in different containers. You also wrote a Docker Compose file which links the two containers together and provides for easy starting up and tearing down of the development environment.
@z

@x
In the next module, you'll take a look at one possible approach to running functional tests in Docker.
@y
In the next module, you'll take a look at one possible approach to running functional tests in Docker.
@z
